<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Palette Builder (Single File)</title>
<style>
  :root{
    --bg:#0b0b0b; --panel:#121212; --text:#e6e6e6; --muted:#9aa; --accent:#59d185;
    --border:#2a2a2a; --chip:#161616; --danger:#ff5a5a;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text);
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
  }
  .app{display:grid; grid-template-columns: 1fr 360px; gap:12px; height:100%;}
  header{grid-column: 1 / -1; padding:10px 12px; background:#101010; border-bottom:1px solid var(--border); display:flex; align-items:center; gap:12px}
  header h1{font-size:14px; margin:0; font-weight:600; color:#cfe8c7}
  .hint{color:var(--muted)}

  /* left: canvas area */
  .stageWrap{position:relative; background:#0e0e0e; border:1px solid var(--border); margin:12px; border-radius:10px; overflow:hidden}
  canvas{display:block; width:100%; height:100%; background:#000}
  .overlay{position:absolute; inset:0; cursor:crosshair;}
  .dropHint{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; color:#ccc; font-size:13px;}
  .dropHint .pill{background:rgba(0,0,0,.5); border:1px dashed #555; padding:8px 12px; border-radius:8px}

  /* selection rectangle (deprecated, hidden) */
  .sel{display:none}

  /* right: controls */
  aside{padding:12px; margin:12px 12px 12px 0; background:var(--panel); border:1px solid var(--border); border-radius:10px; display:grid; gap:12px; align-content:start}
  .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .row label{font-size:12px; color:#cfe8c7}
  input[type="number"], input[type="text"], select, button, input[type="color"]{background:#151515; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:6px 8px; font:12px ui-monospace,Menlo,monospace}
  button.primary{background:#18381f; border-color:#265c35}
  button:disabled{opacity:.6; cursor:not-allowed}

  .swatches{display:grid; grid-template-columns: repeat(auto-fill, minmax(42px,1fr)); gap:6px; border:1px solid var(--border); border-radius:8px; padding:8px; max-height:40vh; overflow:auto; background:#0e0e0e}
  .swatches:focus{ outline:none; box-shadow:none; }
  .swatches:focus-visible{ outline:none; box-shadow:none; }

  .sw{position:relative; height:42px; border-radius:8px; border:1px solid #0006; cursor:pointer; box-shadow: inset 0 0 0 1px #fff2; user-select:none}
  .sw.selected{outline:2px solid rgba(255,255,255,.5)}
  .sw .meta{position:absolute; left:4px; bottom:3px; font:10px ui-monospace,Menlo,monospace; color:#000; text-shadow:0 1px 0 #fff8; mix-blend-mode:screen}

  .publishBox{display:grid; gap:6px}
  textarea{width:100%; min-height:120px; resize:vertical; background:#101010; color:#ddd; border:1px solid var(--border); border-radius:8px; padding:8px; font:12px/1.3 ui-monospace,Menlo,monospace}
  .chips{display:flex; gap:6px; flex-wrap:wrap}
  .chip{background:var(--chip); border:1px solid var(--border); border-radius:999px; padding:4px 8px; font-size:11px; color:#cbd5e1}
  .danger{background:#2a0f0f; border-color:#542}
  .kbd{font:600 10px ui-monospace,Menlo,monospace; padding:2px 6px; border:1px solid #444; border-radius:6px; background:#161616}
  .footer{grid-column: 1 / -1; padding:10px 12px; border-top:1px solid var(--border); color:#9aa;}
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Palette Builder</h1>
      <span class="hint">Drop an image → set count → Sample (whole image) • or click the image to add colors (3×3 avg)</span>
      <span class="chips" style="margin-left:auto">
        <span class="chip">Click image = add 3×3 sample</span>
        <span class="chip">Click swatch = toggle select</span>
        <span class="chip"><span class="kbd">Delete</span> removes selected</span>
        <span class="chip"><span class="kbd">Delete</span>+Click = remove one • <span class="kbd">D</span>+Click = duplicate in place</span>
        <span class="chip">Double-click swatch to edit</span>
      </span>
    </header>

    <div class="stageWrap" id="stage">
      <canvas id="imgCanvas" width="1280" height="800" aria-label="image canvas"></canvas>
      <div class="overlay" id="overlay" title="Click to add a 3×3 averaged color"></div>
      <div class="sel" id="sel"></div>
      <div class="dropHint" id="dropHint"><span class="pill">Drop image here or <button id="pickBtn">Choose…</button></span></div>
      <input type="file" id="fileInput" accept="image/*" style="display:none"/>
    </div>

    <aside>
      <div class="row">
        <label>Colors</label>
        <input id="colorCount" type="number" min="1" max="200" value="32" style="width:80px"/>
        <button id="sampleBtn" class="primary" disabled>Sample</button>
      </div>

      <div class="row">
        <label>Editing</label>
        <input id="picker" type="color" value="#ffffff" title="Color editor"/>
        <span class="hint">(double-click a swatch or use this picker when one is selected)</span>
      </div>

      <div class="row">
        <label>Actions</label>
        <button id="deleteBtn" class="danger">Delete Selected</button>
        <button id="selectAllBtn">Select All</button>
        <button id="sortBtn">Sort (Hue)</button>
      </div>

      <div class="swatches" id="swatches" tabindex="0" aria-label="palette swatches"></div>

      <div class="publishBox">
        <div class="row"><button id="copyBtn" class="primary">Copy JSON</button><span class="hint" id="copyHint"></span></div>
        <textarea id="jsonOut" placeholder="Paste palette here or use Copy JSON. Accepts [[r,g,b,a],…] or legacy [r,g,b,a],[…] (r,g,b in 0–1 or 0–255; a optional)"></textarea>
      </div>
    </aside>

    <div class="footer">Image fits the canvas automatically; “Sample” uses the entire image. Click the image to add 3×3 averaged picks.</div>
  </div>

<script>
(function(){
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('imgCanvas');
  const ctx = canvas.getContext('2d', { willReadFrequently:true });
  const overlay = document.getElementById('overlay');
  const dropHint = document.getElementById('dropHint');
  const fileInput = document.getElementById('fileInput');
  const pickBtn = document.getElementById('pickBtn');

  const colorCount = document.getElementById('colorCount');
  const sampleBtn = document.getElementById('sampleBtn');

  const swatchesEl = document.getElementById('swatches');
  const deleteBtn = document.getElementById('deleteBtn');
  const selectAllBtn = document.getElementById('selectAllBtn');
  const sortBtn = document.getElementById('sortBtn');
  const picker = document.getElementById('picker');

  const copyBtn = document.getElementById('copyBtn');
  const jsonOut = document.getElementById('jsonOut');
  const copyHint = document.getElementById('copyHint');

  let img = null;
  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  let palette = [];     // [{r,g,b,a}]
  let selected = new Set(); // indices

  // track where the image is drawn inside the canvas so we can map clicks
  let lastDraw = {dx:0, dy:0, dw:0, dh:0};

  // --- chorded action modes ---
  const mode = { deleteOnClick:false, duplicateOnClick:false };

  function resizeCanvasToStage(){
    const rect = stage.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    if (img) drawImageFit();
  }
  window.addEventListener('resize', () => requestAnimationFrame(resizeCanvasToStage));

  pickBtn.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', e => {
    const f = e.target.files && e.target.files[0];
    if (f) loadImageFile(f);
  });

  // Drag & drop
  ;['dragenter','dragover'].forEach(ev=> stage.addEventListener(ev, e=>{e.preventDefault(); dropHint.style.visibility='visible';}, {passive:false}));
  ;['dragleave','drop'].forEach(ev=> stage.addEventListener(ev, e=>{e.preventDefault(); if(ev==='drop'){ const file = e.dataTransfer.files[0]; if(file) loadImageFile(file); } dropHint.style.visibility = img? 'hidden':'visible';}, {passive:false}));

  function loadImageFile(file){
    const url = URL.createObjectURL(file);
    const image = new Image();
    image.onload = ()=>{
      URL.revokeObjectURL(url);
      img = image;
      palette=[]; selected.clear(); renderSwatches();
      resizeCanvasToStage(); // ensure correct fit
      drawImageFit();
      dropHint.style.visibility='hidden';
      sampleBtn.disabled=false;
      writeJson();
    };
    image.onerror = ()=>{ URL.revokeObjectURL(url); alert('Could not load that image.'); };
    image.src = url;
  }

  function clearCanvas(){ ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width, canvas.height); ctx.restore(); }

  // Fit the image fully inside the canvas (CONTAIN), preserving aspect ratio
  function drawImageFit(){
    if(!img){ clearCanvas(); return; }
    clearCanvas();
    const cw = canvas.width, ch = canvas.height;
    const iw = img.naturalWidth, ih = img.naturalHeight;
    const cr = cw / ch, ir = iw / ih;

    let dw, dh, dx, dy;
    if (ir > cr){ dw = cw; dh = Math.round(dw / ir); dx = 0; dy = Math.round((ch - dh) / 2); }
    else { dh = ch; dw = Math.round(dh * ir); dy = 0; dx = Math.round((cw - dw) / 2); }
    ctx.drawImage(img, dx, dy, dw, dh);
    lastDraw = {dx, dy, dw, dh};
  }

  // ----- SAMPLING -----
  sampleBtn.addEventListener('click', ()=>{
    if(!img){ alert('Load an image first.'); return; }
    const n = clamp(+colorCount.value|0, 1, 200);
    colorCount.value = String(n);

    const {dx,dy,dw,dh} = lastDraw;
    if (dw<=0 || dh<=0){ alert('Nothing to sample.'); return; }
    try{
      const data = ctx.getImageData(dx|0, dy|0, dw|0, dh|0).data;
      const colors = samplePixels(data);
      palette = kmeans(colors, n, 12);
      selected.clear();
      renderSwatches();
      writeJson();
    }catch(e){ console.error(e); alert('Sampling failed. Try a smaller image.'); }
  });

  // Click on image → add a single averaged 3×3 sample where clicked
  overlay.addEventListener('click', (e)=>{
    if (!img) return;
    const r = overlay.getBoundingClientRect();
    const cx = (e.clientX - r.left) * dpr;
    const cy = (e.clientY - r.top) * dpr;
    const {dx,dy,dw,dh} = lastDraw;
    if (cx < dx || cy < dy || cx >= dx+dw || cy >= dy+dh) return;

    const ix = Math.round(cx), iy = Math.round(cy);
    const half = 1; // 3×3
    const sx = clamp(ix - half, dx|0, (dx+dw-1)|0);
    const sy = clamp(iy - half, dy|0, (dy+dh-1)|0);
    const ex = clamp(ix + half, dx|0, (dx+dw-1)|0);
    const ey = clamp(iy + half, dy|0, (dy+dh-1)|0);
    const sw = ex - sx + 1, sh = ey - sy + 1;

    try{
      const id = ctx.getImageData(sx, sy, sw, sh);
      const d = id.data;
      let rr=0, gg=0, bb=0, cnt=0;
      for(let i=0;i<d.length;i+=4){ rr+=d[i]; gg+=d[i+1]; bb+=d[i+2]; cnt++; }
      const r8 = Math.round(rr/cnt), g8 = Math.round(gg/cnt), b8 = Math.round(bb/cnt);
      palette.push({r:r8,g:g8,b:b8,a:255});
      selected.clear();
      renderSwatches();
      writeJson();
    }catch(err){ console.error(err); }
  });

  function samplePixels(rgba){
    const total = rgba.length/4;
    const target = Math.min(120000, total);
    const step = Math.max(1, Math.floor(total / target));
    const out = [];
    for(let i=0;i<rgba.length;i+=4*step){ out.push(rgba[i], rgba[i+1], rgba[i+2]); }
    return new Uint8Array(out);
  }

  function kmeans(srcRGBu8, k, maxIter){
    if (srcRGBu8.length < 3) return [];
    const N = Math.floor(srcRGBu8.length/3);
    k = Math.min(Math.max(1,k), Math.min(200,N));
    const cents = [];
    const i0 = (Math.random()*N|0)*3; cents.push([srcRGBu8[i0],srcRGBu8[i0+1],srcRGBu8[i0+2]]);
    while(cents.length<k){
      let best=[0,0,0], bestD=-1;
      for(let i=0;i<N;i+=Math.max(1,Math.floor(N/4096))){
        const r=srcRGBu8[3*i], g=srcRGBu8[3*i+1], b=srcRGBu8[3*i+2];
        let dMin=1e9; for(const c of cents){ const dr=r-c[0], dg=g-c[1], db=b-c[2]; const d=dr*dr+dg*dg+db*db; if(d<dMin) dMin=d; }
        if(dMin>bestD){ bestD=dMin; best=[r,g,b]; }
      }
      cents.push(best);
    }
    const asn = new Uint16Array(N);
    for(let it=0; it<(maxIter||10); it++){
      let moved=0;
      for(let i=0;i<N;i++){
        const r=srcRGBu8[3*i], g=srcRGBu8[3*i+1], b=srcRGBu8[3*i+2];
        let bi=0,bd=1e9; for(let c=0;c<k;c++){ const cr=cents[c][0],cg=cents[c][1],cb=cents[c][2]; const dr=r-cr,dg=g-cg,db=b-cb; const d=dr*dr+dg*dg+db*db; if(d<bd){ bd=d; bi=c; } }
        if (asn[i]!==bi){ asn[i]=bi; moved++; }
      }
      const sum = Array.from({length:k},()=>[0,0,0,0]);
      for(let i=0;i<N;i++){ const a=asn[i]; const j=3*i; sum[a][0]+=srcRGBu8[j]; sum[a][1]+=srcRGBu8[j+1]; sum[a][2]+=srcRGBu8[j+2]; sum[a][3]++; }
      for(let c=0;c<k;c++){ const s=sum[c]; if(s[3]>0){ cents[c][0]=s[0]/s[3]; cents[c][1]=s[1]/s[3]; cents[c][2]=s[2]/s[3]; } }
      if (moved===0) break;
    }
    cents.sort((a,b)=> (0.2126*b[0]+0.7152*b[1]+0.0722*b[2]) - (0.2126*a[0]+0.7152*a[1]+0.0722*a[2]));
    return cents.map(c=>({r:Math.round(c[0]), g:Math.round(c[1]), b:Math.round(c[2]), a:255}));
  }

  function clamp(v,lo,hi){ return Math.min(hi, Math.max(lo, v)); }

  // ---------- Color util: RGB[0-255] -> HSL (0-360, 0-1, 0-1) ----------
  function rgbToHsl(r,g,b){
    r/=255; g/=255; b/=255;
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0, s=0, l=(max+min)/2;
    const d = max-min;
    if (d !== 0){
      s = l>0.5 ? d/(2-max-min) : d/(max+min);
      switch(max){
        case r: h = ((g-b)/d + (g<b?6:0)); break;
        case g: h = ((b-r)/d + 2); break;
        case b: h = ((r-g)/d + 4); break;
      }
      h *= 60;
    }
    return [h, s, l];
  }

  // ---------- SWATCH UI (DIVS, CLICKABLE, DELETE/ DUPLICATE CHORDS + dbl-click edit) ----------
  function renderSwatches(){
    swatchesEl.innerHTML = '';
    palette.forEach((c,idx)=>{
      const sw = document.createElement('div');
      sw.className = 'sw' + (selected.has(idx) ? ' selected' : '');
      sw.style.background = `rgb(${c.r},${c.g},${c.b})`;
      sw.dataset.index = String(idx);
      const tag = document.createElement('div');
      tag.className = 'meta';
      tag.textContent = rgbHex(c);
      sw.appendChild(tag);
      swatchesEl.appendChild(sw);
    });
  }

  // Click behavior:
  // - Delete+Click: remove clicked swatch
  // - D+Click: duplicate clicked swatch at same index (original shifts right)
  // - Otherwise: toggle selection
  swatchesEl.addEventListener('click', (e)=>{
    if (e.detail > 1) return; // ignore double-click ripple
    const sw = e.target.closest('.sw');
    if (!sw) { selected.clear(); renderSwatches(); return; }
    const idx = +sw.dataset.index;

    if (mode.deleteOnClick){
      palette.splice(idx, 1);
      selected.clear();
      renderSwatches();
      writeJson();
      return;
    }
    if (mode.duplicateOnClick){
      const c = palette[idx];
      const copy = {r:c.r, g:c.g, b:c.b, a:c.a};
      palette.splice(idx, 0, copy); // insert copy at same index
      selected = new Set([idx]);    // select the new duplicate
      renderSwatches();
      writeJson();
      return;
    }

    // default: toggle selection
    if (selected.has(idx)) selected.delete(idx);
    else selected.add(idx);
    renderSwatches();
  });

  // Double-click opens color editor unless we’re in a chorded mode
  swatchesEl.addEventListener('dblclick', (e)=>{
    if (mode.deleteOnClick || mode.duplicateOnClick) return; // suppress edit while deleting/duplicating
    const sw = e.target.closest('.sw'); if (!sw) return;
    const idx = +sw.dataset.index;
    if (!selected.has(idx)) { selected.add(idx); renderSwatches(); }
    openColorEditorFor(idx);
  });

  // Click anywhere outside the grid clears selection
  document.addEventListener('mousedown', (e)=>{
    if (!swatchesEl.contains(e.target)){ selected.clear(); renderSwatches(); }
  });

  // Delete button or Delete key (when selection exists) remove selected
  function deleteSelected(){
    if (selected.size===0) return;
    const keep = [];
    palette.forEach((c,i)=>{ if(!selected.has(i)) keep.push(c); });
    palette = keep;
    selected.clear();
    renderSwatches();
    writeJson();
  }
  deleteBtn.addEventListener('click', deleteSelected);

  // Key handling for chord modes + legacy delete-selected
  window.addEventListener('keydown', (e)=>{
    const ae = document.activeElement;
    const typing = ae && (ae.tagName==='INPUT' || ae.tagName==='TEXTAREA' || ae.isContentEditable);
    if (typing) return;

    if (e.key==='Delete' || e.key==='Backspace'){
      e.preventDefault();
      if (selected.size>0){
        deleteSelected();
        mode.deleteOnClick = false;
      } else {
        mode.deleteOnClick = true;
      }
    } else if (e.key==='d' || e.key==='D'){
      mode.duplicateOnClick = true;
    }
  });

  window.addEventListener('keyup', (e)=>{
    if (e.key==='Delete' || e.key==='Backspace') mode.deleteOnClick = false;
    if (e.key==='d' || e.key==='D') mode.duplicateOnClick = false;
  });

  // Select all
  selectAllBtn.addEventListener('click', ()=>{
    selected = new Set(palette.map((_,i)=>i));
    renderSwatches();
  });

  // Sort (Hue) button
  sortBtn.addEventListener('click', ()=>{
    // compute sortable keys; push low-sat (≈grays) to the end
    const GRAY_SAT = 0.08; // threshold
    palette.sort((a,b)=>{
      const [ha,sa,la] = rgbToHsl(a.r,a.g,a.b);
      const [hb,sb,lb] = rgbToHsl(b.r,b.g,b.b);
      const ga = sa < GRAY_SAT, gb = sb < GRAY_SAT;
      if (ga !== gb) return ga ? 1 : -1;           // colors first, grays later
      if (!ga) { // both colored → sort by hue, then sat desc, then lightness
        if (ha !== hb) return ha - hb;
        if (sa !== sb) return sb - sa;
        if (la !== lb) return la - lb;
      } else {  // both gray → sort by lightness
        if (la !== lb) return la - lb;
      }
      // perfect tie: stabilize by RGB so identicals sit together
      if (a.r !== b.r) return a.r - b.r;
      if (a.g !== b.g) return a.g - b.g;
      return a.b - b.b;
    });
    selected.clear();
    renderSwatches();
    writeJson();
  });

  // Color editing (applies to all selected)
  function rgbHex(c){
    const h = (x)=> x.toString(16).padStart(2,'0');
    return '#'+h(c.r)+h(c.g)+h(c.b);
  }
  function openColorEditorFor(idx){
    const c = palette[idx]; if (!c) return;
    picker.value = rgbHex(c);
    picker.click();
  }
  picker.addEventListener('input', ()=>{
    if (selected.size===0) return;
    const hex = picker.value;
    const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
    for (const i of selected){ const c = palette[i]; if (!c) continue; c.r=r; c.g=g; c.b=b; }
    renderSwatches();
    writeJson();
  });

  // ---------- JSON Sync (copy + import from textarea) ----------
  let _writingJson = false;

  // Pretty legacy flat format with newline after every 4 colors
  function writeJson(){
    const items = palette.map(c=> {
      const a = [ +(c.r/255).toFixed(3), +(c.g/255).toFixed(3), +(c.b/255).toFixed(3), 1 ];
      return `[${a.join(',')}]`;
    });
    const lines = [];
    for (let i=0;i<items.length;i+=4){
      lines.push(items.slice(i, i+4).join(','));
    }
    const text = lines.join(',\n'); // newline after each group of 4
    _writingJson = true;
    jsonOut.value = text;
    _writingJson = false;
  }

  // Normalize one [r,g,b,(a?)] where r,g,b can be 0–1 or 0–255; returns {r,g,b,a}
  function normalizeColor(a){
    if (!Array.isArray(a) || a.length < 3) return null;
    let [r,g,b,al=1] = a.map(Number);
    const anyGt1 = r>1 || g>1 || b>1 || al>1;
    if (anyGt1){ r/=255; g/=255; b/=255; if (al>1) al = al/255; }
    r = Math.round(clamp(r,0,1)*255);
    g = Math.round(clamp(g,0,1)*255);
    b = Math.round(clamp(b,0,1)*255);
    const a8 = Math.round(clamp(al,0,1)*255);
    return {r,g,b,a:a8};
  }

  function tryParsePalette(text){
    if (!text || !text.trim()) return null;
    // First try direct JSON
    try {
      const arr = JSON.parse(text);
      if (Array.isArray(arr)) return arr;
    } catch(_){/* fallthrough */}
    // Try legacy "flat" format: [r,g,b,a],[...]
    try {
      const wrapped = `[${text}]`;
      const arr = JSON.parse(wrapped);
      if (Array.isArray(arr)) return arr;
    } catch(_){/* fail */}
    return null;
  }

  function importFromJsonText(text){
    const raw = tryParsePalette(text);
    if (!raw) return false;
    if (!Array.isArray(raw[0])) return false;

    const next = [];
    for (const t of raw){
      const c = normalizeColor(t);
      if (c) next.push(c);
    }
    if (!next.length) return false;

    palette = next;
    selected.clear();
    renderSwatches();
    return true;
  }

  // Import when user pastes/types valid JSON (debounced, and ignore our own writes)
  let importTimer = null;
  jsonOut.addEventListener('input', ()=>{
    if (_writingJson) return;
    clearTimeout(importTimer);
    importTimer = setTimeout(()=>{
      const ok = importFromJsonText(jsonOut.value);
      copyHint.textContent = ok ? `Imported ${palette.length} color${palette.length!==1?'s':''}.` : '';
    }, 250);
  });

  // Copy JSON button
  copyBtn.addEventListener('click', ()=>{
    writeJson();
    try{
      navigator.clipboard.writeText(jsonOut.value);
      copyHint.textContent = 'Copied to clipboard.';
      setTimeout(()=>copyHint.textContent='', 1500);
    }catch(_){
      copyHint.textContent = '';
    }
  });

  // init
  resizeCanvasToStage();
  dropHint.style.visibility = 'visible';
})();
</script>
</body>
</html>
